#include <QImageReader>
#include <QFileInfo>
#include <QStringList>
#include "csv.h"
#include "csvparser.h"
#include "common/evdata.h"
#include "GUI/icons.h"

// Wheellog CSV column headers
#define ENUM_WHEELLOG_COLUMNS(F)	\
	/* Android's GPS data */ \
	F(date) F(time) F(datetime) F(latitude) F(longitude) F(gps_speed) F(gps_alt) F(gps_heading) F(gps_distance) \
	/* Electric Vehicle data */ \
	ENUM_EVDATA_SCALARS(F) \
	F(mode) F(alert)

#define DRIVE_MODE	"Drive"
#define MIN_SEGMENT_SIZE	100

bool CSVParser::parse_waypoints(QFile *file, QList<TrackData> &tracks,
  QList<RouteData> &routes, QList<Area> &polygons,
  QVector<Waypoint> &waypoints)
{
	Q_UNUSED(tracks);
	Q_UNUSED(routes);
	Q_UNUSED(polygons);
	CSV csv(file);
	QStringList entry;
	bool ok;


	while (!csv.atEnd()) {
		if (!csv.readEntry(entry) || entry.size() < 3) {
			_errorString = "Parse error";
			_errorLine = csv.line();
			return false;
		}

		double lon = entry.at(0).trimmed().toDouble(&ok);
		if (!ok || (lon < -180.0 || lon > 180.0)) {
			_errorString = "Invalid longitude";
			_errorLine = csv.line();
			return false;
		}
		double lat = entry.at(1).trimmed().toDouble(&ok);
		if (!ok || (lat < -90.0 || lat > 90.0)) {
			_errorString = "Invalid latitude";
			_errorLine = csv.line();
			return false;
		}
		Waypoint wp(Coordinates(lon, lat));
		wp.setName(entry.at(2).trimmed());
		if (entry.size() > 3)
			wp.setDescription(entry.at(3).trimmed());

		waypoints.append(wp);

		entry.clear();
	}

	return true;
}

// Parse logs generated by Wheellog Android app (Electric Unicycle logger)
// (https://github.com/palachzzz/WheelLogAndroid.git)

// Log file column header (first line)
static struct {
	const char *name;
	int column;
} WlColumns[] = {
#define F_STRUCT(n)	{#n, -1},
ENUM_WHEELLOG_COLUMNS(F_STRUCT)
#undef F_STRUCT
};

typedef enum {
#define F_ENUM(n)	wl_##n##_idx,
ENUM_WHEELLOG_COLUMNS(F_ENUM)
#undef F_ENUM
	wl_idx_total
} WlColumn_t;

static QString get_column_str(const QList<QByteArray> &list, WlColumn_t column)
{
	int col = WlColumns[column].column;
	if (col == -1) {
		return QString::Null();
	}
	QByteArray ba = list[col].trimmed();
	return QString::fromUtf8(ba.data(), ba.size());
}

bool CSVParser::parse_wheellog(QFile *file, QList<TrackData> &tracks,
	QList<RouteData> &routes, QList<Area> &polygons,
	QVector<Waypoint> &waypoints)
{
	Q_UNUSED(routes);
	Q_UNUSED(polygons);

	_errorLine = 1;
	_errorString.clear();

	// First line is the header
	file->seek(0);
	QByteArray line = file->readLine();
	QList<QByteArray> header_list = line.split(',');
	if (header_list.size() < 4) {
		_errorString = "Parse error";
		return false;
	}

	// Obtain the column indicies to be extracted
	for (size_t idx = 0; idx < sizeof(WlColumns) / sizeof(*WlColumns); idx++)
		WlColumns[idx].column = -1;
	for (int col = 0; col < header_list.size(); col++) {
		QByteArray ba = header_list[col].trimmed();
		QString name = QString::fromUtf8(ba.data(), ba.size());		

		for (size_t idx = 0; idx < sizeof(WlColumns) / sizeof(*WlColumns); idx++) {
			if (name == WlColumns[idx].name) {
				if (WlColumns[idx].column == -1) {
					WlColumns[idx].column = col;
					break;
				}
				else {
					_errorString = "Duplicate column header: " + name;
					return false;
				}
			}
		}
	}

	// Check for mandatory columns
	if (WlColumns[wl_latitude_idx].column == -1 || WlColumns[wl_longitude_idx].column == -1) {
		_errorString = "Missing latitude and/or longitude columns";
		return false;
	}

	_errorLine++;

	tracks.append(TrackData());
	tracks.last().append(SegmentData());

	// Keep the file-name and the full-path name
	QString fileName(QFileInfo(*file).fileName());
	tracks.last().setName(fileName);
	tracks.last().setDescription(file->fileName());

	QString last_mode;
	QDateTime last_time_stamp;

	while (!file->atEnd()) {
		line = file->readLine().trimmed();
		// Ignore empty lines
		if (line.isEmpty()) {
			_errorLine++;
			continue;
		}

		QList<QByteArray> list = line.split(',');
		if (list.size() < header_list.size()) {
			_errorString = "Insufficient parameter number";
			return false;
		}

		// Sometimes, the last column (alert) contain commas,
		// merge back items entries after the last header column
		while (list.size() > header_list.size()) {
			int last = list.size() - 1;
			list[last - 1] += "," + list[last];
			list.removeLast();
		}

		Coordinates coords;
		QDateTime time_stamp;
		Trackpoint trackpoint;
		EVData evdata;

		for (int idx = 0; idx < sizeof(WlColumns) / sizeof(*WlColumns); idx++) {
			QString str_val = get_column_str(list, static_cast<WlColumn_t>(idx));
			bool res = !str_val.isNull();
			if (!res)
				continue;

			// Convert to float if necessary
			double float_val = (double)NAN;
			switch (idx)
			{
			// These columns contain strings or date-time
			case wl_date_idx: case wl_time_idx: case wl_datetime_idx: case wl_mode_idx: case wl_alert_idx:
				//qDebug("%d(%s): %s\n", idx, WlColumns[idx].name, qUtf8Printable(str_val));
				break;
			// Other columns contain float numbers
			default:
				float_val = str_val.toDouble(&res);
				//qDebug("%d(%s): %f\n", idx, WlColumns[idx].name, float_val);
			}
			if (!res)
				continue;

			switch (idx)
			{
			/* Android's GPS data */
			case wl_date_idx:			time_stamp.setDate(QDate::fromString(str_val, Qt::ISODate)); break;
			case wl_time_idx:			time_stamp.setTime(QTime::fromString(str_val)); break;
			case wl_datetime_idx:		time_stamp = QDateTime::fromString(str_val, Qt::ISODate); break;
			case wl_latitude_idx:		coords.setLat(float_val); break;
			case wl_longitude_idx:		coords.setLon(float_val); break;
			case wl_gps_speed_idx:		trackpoint.setSpeed(float_val / 3.6); break;	// km/h -> m/s
			case wl_gps_alt_idx:		trackpoint.setElevation(float_val); break;
			case wl_gps_heading_idx:	break;
			case wl_gps_distance_idx:	break;
			/* Electric Vehicle data */
			case wl_speed_idx:			evdata.setScalar(EVData::t_speed, float_val); break;
			case wl_voltage_idx:		evdata.setScalar(EVData::t_voltage, float_val); break;
			case wl_current_idx:		evdata.setScalar(EVData::t_current, float_val); break;
			case wl_power_idx:			evdata.setScalar(EVData::t_power, float_val); break;
			case wl_battery_level_idx:	evdata.setScalar(EVData::t_battery_level, float_val); break;
			case wl_distance_idx:		evdata.setScalar(EVData::t_distance, float_val); break;
			case wl_totaldistance_idx:	evdata.setScalar(EVData::t_totaldistance, float_val); break;
			case wl_system_temp_idx:	evdata.setScalar(EVData::t_system_temp, float_val); break;
			case wl_cpu_temp_idx:		evdata.setScalar(EVData::t_cpu_temp, float_val); break;
			case wl_tilt_idx:			evdata.setScalar(EVData::t_tilt, float_val); break;
			case wl_roll_idx:			evdata.setScalar(EVData::t_roll, float_val); break;
			case wl_mode_idx:			evdata.setMode(str_val); break;
			case wl_alert_idx:			evdata.setAlert(str_val); break;
			}
		}

		trackpoint.setTimestamp(time_stamp);
		trackpoint.setCoordinates(coords);
		trackpoint.setEVData(evdata);

		// Skip non-geolocated points (concider changing this)
		if (coords.isValid()) {
			// Avoid problems with unordered time-stamps by ignoring them
			// TODO: Must sort the log
			if (last_time_stamp < time_stamp) {
				last_time_stamp = time_stamp;

#if 1 // New segment on Drive-mode start
				if (last_mode != evdata.mode() && evdata.mode() == DRIVE_MODE && tracks.last().last().size() > MIN_SEGMENT_SIZE) {
					tracks.last().append(SegmentData());
				}
#endif
				tracks.last().last().append(trackpoint);
			}
			else {
				qDebug() << "Warning: Ignored unordered time-stamp" << time_stamp.toString() << ", at line" << _errorLine;
			}

			// Add waypoint on alert or mode change
			if (evdata.hasAlert() || last_mode != evdata.mode()) {
				Waypoint waypoint(coords);
				waypoint.setTimestamp(time_stamp);
				waypoint.setElevation(trackpoint.elevation());
				waypoint.setName(evdata.hasAlert() ? "ALERT" : evdata.mode());
				QString descr;
				QTextStream(&descr) << "Line " << _errorLine << ": " << evdata.alert();
				waypoint.setDescription(descr);
#if 1	//Experimental: Add icons
				static ImageInfo poiIcon(SHOW_POI_ICON, QImageReader(SHOW_POI_ICON).size());
				static ImageInfo alertIcon(CLOSE_FILE_ICON, QImageReader(CLOSE_FILE_ICON).size());
				waypoint.addImage(evdata.hasAlert() ?  alertIcon : poiIcon);
#endif
				waypoints.append(waypoint);
			}

			// Keep the last mode
			last_mode = evdata.mode();
		}

		_errorLine++;
	}

	return true;
}

bool CSVParser::parse(QFile *file, QList<TrackData> &tracks,
	QList<RouteData> &routes, QList<Area> &polygons,
	QVector<Waypoint> &waypoints)
{
	// Try Garmin waypoints format
	if (!parse_waypoints(file, tracks, routes, polygons, waypoints))
		// Try Wheellog format
		return parse_wheellog(file, tracks, routes, polygons, waypoints);

	return true;
}
